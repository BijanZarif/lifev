%
%
% SUMMARY:
% USAGE:
%
% AUTHOR:       Gilles Fourestey
% ORG:          EPFL
% E-MAIL:       foureste@iacspc.epfl.ch
%
% ORIG-DATE: 24-Nov-08 at 14:03:21
% LAST-MOD:  4-Feb-09 at 12:51:49 by Gilles Fourestey
%
% DESCRIPTION:
% DESCRIP-END.


Let us consider flow of a viscous and incompressible fluid described by its velocity $u$
and pressure $p$. Its flow can be described, at low reynolds number, by the Oseen Problem :

\begin{equation} \label{eqn-oseen}
\left\{
\begin{array}{lc}
\displaystyle \alpha u + \beta \cdot \grad u - \nu \Delta u+
\nabla p & = f \\
\displaystyle \nabla \cdot u & = 0  \\
\end{array}
\right.
\end{equation}

were $\nu$ is the kinematic viscosity of the fluid. If we set the convective
acceleration $\beta$ and $\alpha$ to zero, we get the Stokes equations :

\begin{equation} \label{eqn-stokes}
\left\{
\begin{array}{lc}
- \nu \Delta u+
\nabla p & = f \\
\displaystyle \nabla \cdot u & = 0  \\
\end{array}
\right.
\end{equation}

We want to solve the following Stokes problem :

\begin{equation} \label{eqn-stokes}
\left\{
\begin{array}{lc}
\displaystyle - \nu \Delta u+
\nabla p & = f \\
\displaystyle \nabla \cdot u & = 0  \\
u = (1, 0, 0) & \mbox{ on } \partial \Omega_0 \\
u = (0, 0, 0) & \mbox{ on } \partial \Omega_1  \\
u \cdot n = 0 & \mbox { on } \partial \Omega_2\\
\end{array}
\right.
\end{equation}

on the 3D domain represented by :

\vspace{0.5cm}
\begin{center}
\input cavity.pdf_t
\end{center}
\vspace{0.5cm}

These equation can be written in using the following bilinear forms :
\begin{eqnarray*}
\displaystyle \forall u,v \in H^1(\Omega) & : &
a(u,v) = \nu \int_{\Omega}\nabla u \cdot \nabla v dx \\
\displaystyle \forall v \in H^1(\Omega),\mbox{ } q \in L^2(\Omega) & : &
b(v,q) = \int_{\Omega} q\nabla \cdot v dx \\
\end{eqnarray*}\\
which lead us to the variational formulation : let $f
\in L_0(\Omega)$, find $u \in H^1_0(\Omega)$ et $p \in
L^2_0(\Omega)$ such that
\begin{equation} \label{eqn-varia}
\left\{
\begin{array}{rlr}
\displaystyle \alpha (u,v) + a(u,v) + b(v,p) & =  (g,v)
& \hspace{1cm} \forall t \in(0,T), \forall v \in H^1_0(\Omega) \\
b(u,q) & = 0 & \hspace{1cm} \forall t \in (0,T), \forall q \in L^2_0(\Omega)
\end{array}
\right.
\end{equation}
%find $u_h \in X_h$ and $p_h \in M_h$ so that,

In order to solve (\ref{eqn-varia}) using \lifev, create a working directory.
In this directory, copy the following files :

\begin{itemize}
\item Makefile-cavity
\item cavity.cpp
\item data-cavity
\end{itemize}

from the \verb|<lifev directory>/doc/manual/| directory. \verb!cavity.cpp! contains the
C++ code to solve the variational problem (\ref{eqn-varia}). But before compiling it,
let's have a look a the \ixns{Makefile}{GNU Makefile}.

\begin{verbatim}

# path to the compiler
CC               = /usr/bin/g++

SOURCES          = cavity.cpp
OBJECTS          = $(SOURCES:.cpp=.o)
EXECUTABLE       = cavity

LIFELIBPATH      = -L<lifev lib directory path>
LIFELIBS         = -llifefilters -llifesolver -llifefem \
                   -llifealg -llifearray -llifecore -llifemesh
LIFEINCLUDEPATH  = -I<lifev include directory path>

TRILLIBPATH      = -L<trilinos lib directory path>
TRILLIBS         = -laztecoo -laztecoo -ltriutils -lml \
                   -lifpack -lamesos -lepetraext -lepetra \
                   -lteuchos  -llapack -lblas
TRILINCLUDEPATH  = -I<trilinos include directory path>

MPILIBPATH       = -L<mpi lib directory path>
MPILIBS          = -lmpi_cxx -lmpi
MPIINCLUDEPATH   = -I<mpi include directory path>

METISLIBPATH	 = -L<parmetis lib directory path>
METISLIBS        = -lparmetis -lmetis
METISINCLUDEPATH = -I<parmetis include directory path>

# uncomment this part for optimized compilation
LDFLAGS         = -c -g0 -O2 -DTHREEDIM -lm
# uncomment this part for debugging
#LDFLAGS         = -c -g2 -O0 -DTHREEDIM -lm


all: $(OBJECTS) $(EXECUTABLE)

$(OBJECTS): $(SOURCES)
	$(CC) $(LDFLAGS) \
	$(MPIINCLUDEPATH) $(TRILINCLUDEPATH) $(LIFEINCLUDEPATH) \
	$(SOURCES) -o $@

$(EXECUTABLE): $(OBJECT)
	echo "compiling the executable ... "
	$(CC) $(CFLAGS) \
	$(OBJECTS) $< -o $@ \
	$(LIFELIBPATH) $(LIFELIBS) $(LIFEINCLUDEPATH) \
	$(TRILLIBPATH) $(TRILLIBS) $(TRILINCLUDEPATH) \
	$(METISPATH) $(METISLIBS) $(METISINCLUDE) \
	$(MPILIBPATH) $(MPILIBS) $(MPIINCLUDEPATH) \


clean:
	rm -rf *o cavity

\end{verbatim}


In order to make everything work, you need to fill the \verb|<...>| with your local
configuration paths. You can also change the \verb|LDFLAGS| options in order to
compile using the debug or the optimized mode in the g++ compiler. More information
about the using makefiles are available at \url{http://www.gnu.org/software/make/manual/make.html}.


\begin{verbatim}

#include "Epetra_config.h"
#include "Epetra_MpiComm.h"

\end{verbatim}

This part is mendatory in order to define the Epetra Communicators and should be
at the begining of each program.


\begin{verbatim}
#include <boost/program_options.hpp>

#include <life/lifecore/life.hpp>
#include <life/lifecore/application.hpp>

#include "mpi.h"

#include <life/lifearray/EpetraMatrix.hpp>
#include <life/lifealg/EpetraMap.hpp>
#include <life/lifemesh/partitionMesh.hpp>
#include <life/lifesolver/dataNavierStokes.hpp>
#include <life/lifefem/FESpace.hpp>
#include <life/lifefem/bdfNS_template.hpp>
#include <life/lifefilters/ensight.hpp>

#include <life/lifesolver/Oseen.hpp>

#include <iostream>
\end{verbatim}



\begin{verbatim}
using namespace LifeV;
\end{verbatim}

Using this procedure, we are now able to use LifeV contents without refering to LifeV:: everytime.
Without it, we have to use LifeV::RefFE instead of just RefFE for instance.


\begin{verbatim}

typedef boost::function<Real ( Real const&,
                               Real const&,
                               Real const&,
                               Real const&,
                               ID const& )> fct_type;

typedef Oseen< RegionMesh3D<LinearTetra> >::vector_type  vector_type;
typedef boost::shared_ptr<vector_type>                   vector_ptrtype;

Real zero_scalar( const Real& /* t */,
                  const Real& /* x */,
                  const Real& /* y */,
                  const Real& /* z */,
                  const ID& /* i */ )
{
    return 0.;
}

Real uLid(const Real& t, const Real& /*x*/, const Real& /*y*/, const Real& /*z*/, const ID& i)
{
  switch(i) {
  case 1:
    return 1.0;
    break;
  case 3:
      return 0.0;
      break;
  case 2:
      return 0.0;
    break;
  }
  return 0;
}

\end{verbatim}

In this section, we have defined real functions that will be used in the boundary condition
object. Boundary conditions functions must be defined using the following scheme :

\begin{verbatim}

Real function_name ( const Real& time,
                     const Real& x, const Real& y, const Real& z,
                     const ID&   id )

\end{verbatim}

where
\verb|time|
is the simulation time,
\verb|x, y, z|
are the space coodinates, and
\verb|ID|

is the component of the variable we want to set.
In our example, we want to set $(u_x, u_y, u_z) = (1, 0, 0)$ when we are in ${\partial \Omega}_1$
Therefore, when the ID is 1, i.e $x$, we return 1. For every other cases, i.e $y$ and $z$,
we return 0. We could have used another boundary condition, for instance :

\begin{verbatim}\end{verbatim}
\begin{verbatim}
Real uLid(const Real& t, const Real& /*x*/, const Real& /*y*/, const Real& /*z*/, const ID& i)
{
  switch(i) {
  case 1:
      return x*(1 - x);
      break;
  case 3:
      return 0.0;
      break;
  case 2:
      return 0.0;
      break;
  }
  return 0;
}
\end{verbatim}


The main difference is that, using this functions, the boundary condition on ${\partial \Omega}_1$
now becomes :
\begin{equation*}
  u = (x(1 - x), 0, 0) & \mbox{ on } {\partial \Omega}_0 \\
\end{equation*}

We can now proceed to the main block of the code.

\begin{verbatim}
int
main( int argc, char** argv )
{

    //
    // Mpi Communicator definition ( see http://www.mpi-forum.org/docs/docs.html for documentation ).
    // The communicator (paralell or sequential) is then given to Epetra.
    // This is standard and can be "copy/pasted"
    //

    MPI_Init(&argc, &argv);
    Epetra_MpiComm comm(MPI_COMM_WORLD);

\end{verbatim}

These two lines will initialize the MPI process and create an Epetra communicator
that will be used throughout the code to establish communications. See
\begin{itemize}
\item \url{http://www-unix.mcs.anl.gov/mpi/www/www3/MPI\_Init.html}
\item \url{http://trilinos.sandia.gov/packages/docs/r6.0/packages/epetra/doc/html/classEpetra\_MpiComm.html}
\end{itemize}
for more explanations.

\begin{verbatim}
    // a flag to see who's the leader for output purposes
    bool verbose = comm.MyPID() == 0;

    if ( comm.MyPID() == 0 )
        {
            cout << "% using MPI" << endl;
            int ntasks;
            int err = MPI_Comm_size(MPI_COMM_WORLD, &ntasks);
            std::cout << "My PID = " << comm.MyPID() << " out of "
                      << ntasks << " running." << std::endl;
        }
\end{verbatim}
This block, although not necessary in the comprehention of the FE resolution code, explains
how to manage output from a parallel code. As we do not want every processor to output
every piece of information, we set a ``leader'' processor that will display relevant
informations on the console ( 0 in our case ).
\begin{verbatim}

    // We now proceed to the data file. Its name can be given using the
    // -f or --file argument after the name of launch program.
    // By default, it's data.

    GetPot command_line(argc, argv);
    const char* data_file_name = command_line.follow("data", 2, "-f", "--file");
    GetPot dataFile( data_file_name );

\end{verbatim}

\noident In this part, a GetPot object (http://getpot.sourceforge.net/) is created
and is linked to a data description file using  the ``-f'' ou ``--file'' parameters after
the main program name. This GetPot object is used to store values like
\begin{itemize}
\item the mesh name,
\item the time step,
\item the discretization order,
\item the problem physic
\item solver informations
\item ...
\end{itemize}
You can browse the default data file in every testsuite directory to see examples.
Some entries are mendatory, like the mesh name for instance, others are not and will be
filled with a default value if not specified.\\
A data object will be used to store these informations. In our case, since we want to
solve a Navier-Stokes problem, we will be using the DataNavierStokes object.
Given the GetPot object we have just defined, it will parse the specified data file
to retreive all necessary informations in order to run the simulation.

\begin{verbatim}

    // everything ( mesh included ) will be stored in a class
    DataNavierStokes<RegionMesh3D<LinearTetra> > dataNavierStokes( dataFile );

\end{verbatim}

\begin{table}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
Name & Options & Description \\
\hline \hline
mesh\_dir & & mesh directory path \\ \hline
mesh\_name & & mesh file name \\ \hline
timestep & & problem time step \\ \hline
vel\_order & P1 & volicity discretization order \\ \
& P1Bubble & \\
& P2 & \\ \hline
press\_order & P1 & pressure discretization order \\
& P2 & \\ \hline
order\_bdf & 1 & time discretization order \\
& 2 & \\ \hline
\end{tabular}
\end{center}
\caption{ Dluid discretization parameters description
\ixt{Fluid discretization parameters}{Fluid discretization}}
\label{table-bcparams}
\end{table}


\noident After this line, everything we need to know about our problem is stored
in dataNavierStokes. It is time to proceed the solver definition. \\

In order to build a FE solver to solve our cavity problem, we need :
\begin{itemize}
\item boundary conditions
\item a finite element space
\item a solver that will build and solve the linear system derived from our weak formulation
\end{itemize}


\begin{verbatim}
    // Now for the boundary conditions :
    // BCHandler is the class that stores the boundary conditions. Here we will
    // set 3 boundary conditions :
    // top               : (ux, uy, uz) = (1., 0., 0.) essential BC
    // left, right, down : (ux, uy, uz) = (0., 0., 0.) essential BC
    // front and rear    : uz = 0 essential BC

    BCHandler bcH(3);

    std::vector<ID> zComp(1);
    zComp[0] = 3;

    BCFunctionBase uIn  ( boost::bind(&uLid, _1, _2, _3, _4, _5) );
    BCFunctionBase uZero( zero_scalar );

    // boundary conditions definition.
    // the first two are classical essential or dirichlet conditions
    bcH.addBC( "Upwall",   UPWALL,   Essential, Full,      uIn,   3 );
    bcH.addBC( "Wall",     WALL,     Essential, Full,      uZero, 3 );
\end{verbatim}

Bondary conditions \ixv{Boundary Conditions} part. Here is the prototype of the \verb!addBC! function :

\begin{verbatim}
    //! add new BC to the list (user defined function)
    /*!
      \param name the name of the boundary condition
      \param flag the mesh flag identifying the part of the mesh where the boundary condtion applies
      \param type the boundary condition type: Natural, Essential, Mixte
      \param mode the boundary condition mode: Scalar, Full, Component, Normal, Tangential
      \param bcf the function holding the user defined function involved in this boundary condition
      \param std::vector<ID> storing the list of components involved in this boundary condition
    */
    void addBC( const std::string&     name,
                const EntityFlag&      flag,
                const BCType&          type,
                const BCMode&          mode,
                BCFunctionBase&        bcf,
                const std::vector<ID>& comp );
\end{verbatim}
\verb!name! is a boundary condition description string,
\verb!flag! is the boundary condition number as defined in the mesh,
\verb!mode! is the mode, \verb!bcf! is the function holding the user-defined function involved
in the boundary condition. \verb!type! and \verb!mode! are respectively the boundary condition type
and mode. Please refer to the table (\ref{table-bcparam) for a description of their values.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
Name & Options & Description \\
\hline \hline
type &  Natural & Neumann\\
& Essential & dirichlet \\
& Mixte & Robin\\

\hline
mode & Scalar & 1 dimension BC \\
& Full & 3 component BC \\
& Component  & Sepate compenent BC \\
& Normal & Normal BC \\
& Tangential & Tangential BC \\
\hline

\end{tabular}
\end{center}
\caption{ Boundary Condition parameters description
\ixt{Boundary Conditions parameters}{Boundary Conditions}}
\label{table-bcparams}
\end{table}

\verb!comp! is a vector storing the components involved in the boundary condition.
The last boundary condition we want to impose is a little more tricky.As defined
in (\ref{eqn-stokes}), we have decided that boundary condition \verb!SLIPWALL! ( i.e 20 in the mesh file, or $\partial \Omega_2$ in (\ref{eqn-stokes}) ), will recive
a boundary slipwall condition, i.e
\begin{equation}\label{eqn-slipwallbc}
u \cdot n = 0
\end{equation}
This means, since the two concerned planes are defined by $z = 0$ and $z = L$, that
\begin{equation*}
u_z = 0 \mbox{ for } z=1,L
\end{equation*}
In order to set our third component (\verb!z!), we define the vector :
\begin{verbatim}
    std::vector<ID> zComp(1);
    zComp[0] = 3;
\end{verbatim}
Then, we call add an essential (Dirichlet) boundary condition on the z component by calling
\begin{verbatim}
    // this bc is imposed only on some compenants, that is the ones given in zComp
    // Here it's the thirs, ie z, in order to have u.n = 0
    bcH.addBC( "Slipwall", SLIPWALL, Essential, Component, uZero, zComp );
\end{verbatim}
This will set a null function to the third component on the sleepwall. We could have just easily defined
another function for the others components using the same procedure.

Now that boundary conditions are set, let's have the mesh \ixv{Mesh}. LifeV partitions meshes \ixns{Paritioning}{Mesh}on the fly
using the parMetis libreary, that means that you do not have to provide the partioned mesh in
order to have the simulation running.

\begin{verbatim}

    // partitioning the mesh
    partitionMesh< RegionMesh3D<LinearTetra> >   meshPart(*dataNavierStokes.mesh(), comm);

\end{verbatim}

In our case, after the call to the \verb!partitionMesh! constructor, \verb!meshPart! will store
the local partitioned mesh. Using this local mesh, we can create our Finite Element \ixt{Finite Element Space}{Finite Element} spaces.
In \lifev, a Finite Element Space is a class storing :
\begin{description}
\item a mesh,
\item a reference Lagrangian Finite Element,
\item quadrature rules to integrate reference functions on the mesh elements or the boundaries.
\end{description}
A reference Lagrangian Finite Element in \lifev is a classe containing the geometrical definition
of the mesh elements and the polynomial approximation order we want to use.
Let's have a look a the code :

\begin{verbatim}

    // Now we proceed with the FESpace definition
    // here we decided to use P2/P1 elements



    const RefFE*    refFE_vel;
    const QuadRule* qR_vel;
    const QuadRule* bdQr_vel;


    refFE_vel = &feTetraP2;
    qR_vel    = &quadRuleTetra15pt; // DoE 5
    bdQr_vel  = &quadRuleTria3pt;   // DoE 2

\end{verbatim}

After these lines, \verb!refFE_vel! contains the desired reference finite element  \ixns{Reference Finite Element}{Finite Element}. See table \ref{table-feapproxorder}
for the descrition of available parameters.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
Name  & Description \\
\hline \hline
feTetraP1 & P1 finite element on Tetrahedron \\
feTetraP1Bubble & P1-Bubble finite element on Tetrahedron \\
feTetraP2 & P2 finite element on Tetrahedron \\
\hline
\end{tabular}
\end{center}
\caption{ Reference Finite Element parameters}
\label{table-feapproxorder}
\end{table}

Quadrature rules \ixv{Quatrature Rules} are defined according the polynomial order we have defined.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
Name  & Description & exact p. order\\
\hline \hline
quadRuleTetra1pt   & 1 point & 1 \\
quadRuleTetra3pt   & 3 point & 2 \\
quadRuleTetra5pt   & 5 point &   \\
quadRuleTetra15pt  & 15 point &  \\
quadRuleTetra64pt  & 64 point &  \\
\hline
\end{tabular}
\end{center}
\caption{ Quadrature Rule description}
\label{table-feapproxorder}
\end{table}

Everything is ready to create our Finite Element space :

\begin{verbatim}

    // Everything is ready to build the FE space
    // first the velocity FE space

    if (verbose)
        std::cout << "Building the velocity FE space ... " << std::flush;

    FESpace< RegionMesh3D<LinearTetra>, EpetraMap > uFESpace(meshPart,
                                                             *refFE_vel,
                                                             *qR_vel,
                                                             *bdQr_vel,
                                                             3,
                                                             comm);

\end{verbatim}

We have now defined the reference finite element as P2 and defined two quadrature rule: one general and one
for the boundary integration. Once these classes are defined, we call the FE space
object constructor with the following input parameters :
\begin{itemize}
\item meshPart is the local partioned mesh,
\item *refFE\_vel is the reference finite element,
\item *qR\_vel and *bdQR\_vel are the quadratic rules,
\item 3 is the field dimension,
\item comm is the trilinos communicator.
\end{itemize}

Of course, we do the same with the pressure. This time, we will use a P1 discretization.

\begin{verbatim}

    const RefFE*    refFE_press;
    const QuadRule* qR_press;
    const QuadRule* bdQr_press;

    refFE_press = &feTetraP1;
    qR_press    = &quadRuleTetra4pt;  // DoE 2
    bdQr_press  = &quadRuleTria3pt;   // DoE 2

    if (verbose)
        std::cout << "Building the pressure FE space ... " << std::flush;

    FESpace< RegionMesh3D<LinearTetra>, EpetraMap > pFESpace(meshPart,
                                                             *refFE_press,
                                                             *qR_press,
                                                             *bdQr_press,
                                                             1,
                                                             comm);

\end{verbatim}

Now that our Finite Element spaces are created, we can build the solver. In \lifev,
a solver has the following properties :
\begin{itemize}
\item They build and store the linear FE matrices.
\item They build the preconditioners.
\item They build the linear solvers.
\end{itemize}

Calling the constructor will initialize the matrices, preconditioner and the linear solver
but neither will be constructed. Instead, the matrices will be initialized using the
velocity and pressure FE spaces.

\begin{verbatim}

    // now that the FE spaces are built, we proceed to the NS solver constrution
    // we will use oseen here

    if (verbose) std::cout << "Calling the fluid constructor ... ";

    Oseen< RegionMesh3D<LinearTetra> > fluid (dataNavierStokes,
                                              uFESpace,
                                              pFESpace,
                                              comm);


\end{verbatim}

Now that the class has been instanciated, we need to set it up by passing the data file :

\begin{verbatim}
    // Now, the fluid solver is set up using the data file
    fluid.setUp(dataFile);
\end{verbatim}

Calling \verb|setUp|
will basically build the preconditioner and the linear solver using the AztecOO options \footnote{see \url{http://trilinos.sandia.gov/packages/docs/r9.0/packages/aztecoo/doc/html/classAztecOO.html} for more informations }
contained in the data file.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|}
\hline
name & options\\
\hline \hline
solver & cg \\
& cg\_condnum\\
& gmres (default)\\
& gmres\_condnum\\
& cgs\\
& tfqmr\\
& bicgstab\\
\hline
conv & r0\\
& rhs (default) \\
& Anorm  \\
& noscaled  \\
& sol \\
\hline

precond & none (default) \\
& none \\
&Jacobi \\
&Neumann \\
&ls \\
&sym\_GS \\
&dom\_decomp \\
\hline

scaling & none (default) \\
&    Jacobi \\
&    BJacobi \\
&    row\_sum \\
&    sym\_diag \\
&    sym\_row\_sum \\
&    equil \\
&    sym\_BJacobi \\

\hline

tol   & default : 1e-6  \\

\hline

kspace & default : 30  \\

\hline

max\_iter & default : 500  \\

\hline

drop\_tol & default : 0. \\

\hline

\end{tabular}
\end{center}
\caption{Main parameters for the trilinos solver (see \url{
http://trilinos.sandia.gov/packages/aztecoo/AztecOOUserGuide.pdf} for more informations )
}
\label{table-solveroptions}
\end{table}

Now that the linear solver and the preconditioner are set, we can build the linear system by calling :
\begin{verbatim}
    // the we build the constant matrices
    fluid.buildSystem();
\end{verbatim}

This will create the full finite element linear matrix. Note that, despite the fact
that we passed both the velocity and the pressure FE spaces, the solver will consider
only one finite element constructed by performing a direct sum of the two FE spaces.
The associated ``full'' map can be retrieved using the \verb|getMap| method :

\begin{verbatim}
    // this is the total map ( velocity + pressure ). it will be used to create
    // vectors to strore the solutions

    EpetraMap fullMap(fluid.getMap());

    if (verbose) std::cout << "ok." << std::endl;
\end{verbatim}

Using this map is mendatory when we access the solution vector after the linear system is solved.\\
Before solving our system, let's have a look a the post-precessing class.
In \lifev, we mainly use paraview in order to postprocess our problem solutions.
Writing a paraview solution is quite straightforward using the Ensight class :
we call the Ensight constructor where we give the data file, the mesh and the filename of the solution file,
we give references of the solution vector and that's it.

\begin{verbatim}

    // finally, let's create an exporter in order to view the results
    // here, we use the ensight exporter

    Ensight<RegionMesh3D<LinearTetra> >
           ensight( dataFile, meshPart.mesh(), "cavity", comm.MyPID());

    // we have to define a variable that will store the solution
    vector_ptrtype velAndPressure ( new vector_type(fluid.solution(), Repeated ) );

    // and we add the variables to be saved
    // the velocity
    ensight.addVariable( ExporterData::Vector, "velocity", velAndPressure,
                         UInt(0), uFESpace.dof().numTotalDof() );

    // and the pressure
    ensight.addVariable( ExporterData::Scalar, "pressure", velAndPressure,
                         UInt(3*uFESpace.dof().numTotalDof()),
                         UInt(3*uFESpace.dof().numTotalDof() + pFESpace.dof().numTotalDof()) );

    // everything is ready now
    // a little barrier to synchronize the processes
    MPI_Barrier(MPI_COMM_WORLD);
\end{verbatim}

Here is the occasion to introduce an important concept in \lifev/Trilinos (...).

We are now set for the linear system resolution.

\begin{verbatim}

    vector_type beta( fullMap );
    vector_type rhs ( fullMap );

    beta        *= 0.;
    rhs         *= 0.;

    double alpha = 0.;
\end{verbatim}

Using the full map defined above, we set the advection term and right handside to zero.


\begin{verbatim}
    // updating the system with no mass matrix, advection and rhs set to zero,
    // that is the stokes problem
    fluid.updateSystem(alpha, beta, rhs );
\end{verbatim}

In the Oseen class, \verb|updateSystem| takes 3 arguments :
\begin{itemize}
\item \verb|alpha| is the coefficient in front of the mass term,
\item \verb|beta| is the advection term,
\item \verb|rhs| is the righthand side.
\end{itemize}

Setting these 3 terms to zero will result in solving the system (\ref{eqn-stokes}).
The linear system is solved by calling \verb!iterate!, which requires the boundary conditions
in parameters. The member \verb!iterate! will

\begin{itemize}
\item build the full matrix,
\item apply the boundary conditions,
\item solve the system.
\end{itemize}

\begin{verbatim}
    // iterating the solver in order to produce the solution
    fluid.iterate( bcH );

    // a little postprocessing to see if everything goes according to plan
    *velAndPressure = fluid.solution();
    ensight.postProcess( 0 );

\end{verbatim}

You may now postprocess the result using Paraview.

%
%%%%%%%%%%%%% Some Settings for emacs and auc-TeX
% Local Variables:
% TeX-master: t
% TeX-command-default: "PDFLaTeX"
% TeX-parse-self: t
% TeX-auto-save: t
% x-symbol-8bits: nil
% TeX-auto-regexp-list: TeX-auto-full-regexp-list
% eval: (ispell-change-dictionary "american")
% End:
%
